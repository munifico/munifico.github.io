## try...catch...finally
try 블록의 코드가 HTTP 연결이나 파일 같은 일종의 '자원'을 처리할 때가 있습니다. 프로그램에서 이 자원을 계속 가지고 있을 수는 없으므로 에러가 있든 없든 어느 시점에서는 이 자원을 해제해야 합니다. try 블록에는 문을 원하는 만큼 쓸 수 있고, 그 중 어디서든 에러가 일어나서 자원을 해제할 기회가 아예 사라질 수도 있으므로 try 블록에서 자원을 해제하는 건 안전하지 않습니다. 에러가 일어나지 않으면 실행되지 않는 catch 블록 역시 안전하지 않습니다. 이런 상황에서 finally 블록이 필요합니다. finally 블록은 에러가 일어나든, 일어나지 않든 반드시 호출됩니다.

파일 처리나 HTTP 연결은 다루지 않았으므로, 간단하게 console.log 문을 써서 finally 블록을 실험해 보죠.

~~~javascript
try {
    console.log('this line is executed...');
    throw new Error('whoops');
    console.log('this line is not...');
} catch(err) {
    console.log('there was an error...');
} finally {
    console.log('...always executed.');
    console.log('perform cleanup here');
}
~~~

이 예제를 실행한 후 throw 문을 주석 처리한 후 다시 한 번 실행해 보십시오. finally 블록은 어느 쪽에서든 실행되는 걸 볼 수 있습니다.

~~~javascript
//위 예제를 다음과 같이 변경하여 실행해 보았습니다.
try {
    a(2);
} catch(err) {
    console.log('there was an error...');
} finally {
    console.log('...always executed.');
    console.log('perform cleanup here');
}

const throwError = () => {throw new Error('whoops');}

function a(type) {
    console.log('this line is executed...');
    switch(type) {
        case 1 :
            throwError();
            break;
        case 2 :
            console.log('this line is not...');
            break;
        default:;
    }
}

/*
a(1) : 에러를 일으켰을 때
this line is executed...
there was an error...
...always executed.
perform cleanup here

a(2) : 에러문을 실행시키지 않았을 때
this line is executed...
this line is not...
...always executed.
perform cleanup here
*/
~~~

***
[이전 : 예외 처리와 호출 스택](11.4.md) <br/>
[다음 : 요약](11.6.md) <br/>
[목차](../progressCheck.md)